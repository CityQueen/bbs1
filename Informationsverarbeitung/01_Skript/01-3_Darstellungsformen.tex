\documentclass[11pt,oneside,openany,headings=optiontotoc,11pt,numbers=noenddot]{article}

\input{../../packages.tex}
\input{../../makros.tex}

\setlength{\columnsep}{3em}
\setlength{\columnseprule}{0.5pt}

\geometry{left=1.50cm,right=1.50cm,top=3.00cm,bottom=1.00cm,includeheadfoot}
\pagestyle{plain}
\pagenumbering{arabic}

\begin{document}
	\begin{worksheet}{Informationsverarbeitung}{Lernabschnitt: Strukturiert programmieren}{Darstellungsformen}
		\setlength{\columnseprule}{0pt}
		\setcounter{section}{2}
		\setcounter{page}{6}
		\noindent
		\section{Darstellungsformen von Programmen}
		Viele Problemstellungen sind umfangreich und kompliziert. Systematische Vorarbeit ist nötig, um den Lösungsweg zu beschreiben. Die strukturierte Programmierung verlangt eine gut durch dachte Vorbereitung, bevor mit dem Programmieren begonnen wird.
		\subsection{Pseudocode}
		Der Pseudocode ist eine umgangssprachliche Beschreibung des Programmablaufes, die einer Programmiersprache ähnelt. Ein Pseudocode ist nicht genormt, man kann ihn frei formulieren.
		\begin{framed}
			\noindent
			\underline{Beispiel:}\\
			\begin{itshape}
				\begin{tabularx}{\textwidth}{lX}
					START\\
					& LESE p,q\\
					& BERECHNE \(D = \frac{p^2}{4} - q\)\\
					& WENN \(D < 0\)\\
					& SCHREIBE \grqq{}keine Nullstelle\grqq{}\\
					& SONST BERECHNE \(x_1 = -\frac{p}{2} + \sqrt{D}\)\\
					& BERECHNE \(x_2 = -\frac{p}{2} - \sqrt{D}\)\\
					& SCHREIBE \(x_1, x_2\)\\
					ENDE
				\end{tabularx}
			\end{itshape}
		\end{framed}
		\subsection{Entscheidungstabellen}
		Entscheidungstabellen sind eine bewährte Technik zur Darstellung komplexer Entscheidungslogiken in Anforderungen. Seit 1979 ist die Entscheidungstechnik in der DIN-Norm 66241 standardisiert.
		\subsubsection{Aufbau einer Entscheidungstabelle}
		Eine Entscheidungstabelle besteht grundsätzlich aus vier Elementen oder Quadranten:
		\begin{itemize}[label=-]
			\item \textbf{Bedingungen} beschreiben mögliche Zustände von Objekten.
			\item \textbf{Regeln} oder \textbf{Bedingungsanzeiger} zeigen Kombinationen von Bedingungswerten an.
			\item \textbf{Aktionen} geben an, welche Aktivität abhängig von den gegebenen Regeln auszuführen ist.
			\item \textbf{Aktionszeiger} zeigen die Belegung der Bedingungen mit Aktionen an.
		\end{itemize}
		\begin{tabularx}{\textwidth}{|L{4cm}|L{4cm}|}
			\cline{1-2}
			\textbf{Name der Entscheidungstabelle} & \textbf{Regelnummern}\\
			\cline{1-2}
			Bedingungen & Bedingungsanzeiger\\
			\cline{1-2}
			Aktion & Aktionsanzeiger\\
			\cline{1-2}
		\end{tabularx}
		\newpage
		Zur Erstellung einer Entscheidungstabelle geht man wie folgt vor:
		\begin{itemize}[label=-]
			\item Aktion angeben
			\item Bedingung festlegen
			\item Regeln und Aktionszeiger setzen
			\item Konsolidierung der Entscheidungstabelle
			\item Prüfung auf Widerspruchsfreiheit und Vollständigkeit
		\end{itemize}
		Eine \textbf{vollständige Entscheidungstabelle} liegt vor wenn alle möglichen Bedinungskombinationen im Quadranten \grqq{}Bedingungsanzeiger\grqq{} eingetragen sind. Bei \textbf{n} Bedingungen gibt es \(\mathbf{2^n}\) mögliche Bedingungskombinationen.\\
		\par\noindent
		Ist eine Bedingung erfüllt, dann lautet der Bedingungsanzeiger J (für Ja) bzw. Y (für Yes). Ist sie nicht erfüllt, dann wird N (für Nein oder No) eingetragen.\\
		\par\noindent
		Im letzten Schritt wird jede Bedingungskombination betrachtet und entsprechend der Problembeschreibung im Quadranten \grqq{}Aktionsanzeiger\grqq{} ein Kreuz (X) eingetragen, wenn eine entsprechende Aktion auszuführen ist.\\
		\par\noindent
		\begin{tabularx}{\textwidth}{|l||M|M|M|M|M|M|M|M|}
			\hline
			\textbf{Name der Tabelle} & \textbf{R1} & \textbf{R2} & \textbf{R3} & \textbf{R4} & \textbf{R5} & \textbf{R6} & \textbf{R7} & \textbf{R8}\\
			\hline
			Bedingung 1 & J & J & J & J & N & N & N & N\\
			\hline
			Bedingung 2 & J & J & N & N & J & J & N & N\\
			\hline
			Bedingung 3 & J & N & J & N & J & N & J & N\\
			\hline
			\hline
			Aktion 1 & X & & & & X & & X & \\
			\hline
			Aktion 2 & & X & & & & X & & \\
			\hline
			Aktion 3 & X & & X & X & & X & & X\\
			\hline
			Aktion 4 & & & X & X & & & X & \\
			\hline
			Aktion 5 & & & & & & & & X\\
			\hline
		\end{tabularx}\\
		\par\noindent
		Bei einer Entscheidungstabelle unterscheidet man zwischen zwei Arten der Vollständigkeit. Dabei bezeichnet man eine Entscheidungstabelle, die im Bedingungsanzeigerteil alle möglichen Kombinationen angibt als \textbf{formal vollständige Entscheidungstabelle}.\\
		Eine Entscheidungstabelle, die alle praktisch möglichen Kombinationen aufführt wird als \textbf{inhaltlich vollständig} bezeichnet.\\
		\subsubsection*{Beispiel zweier Entscheidungstabellen}
		\textbf{Formal vollständige Entscheidungstabelle}\\
		\begin{tabularx}{\textwidth}{|l||M|M|M|M|M|M|M|M|}
			\hline
			\textbf{Scheckeinlösung} & \textbf{R1} & \textbf{R2} & \textbf{R3} & \textbf{R4} & \textbf{R5} & \textbf{R6} & \textbf{R7} & \textbf{R8}\\
			\hline
			Überschreitungsbetrag < 300\euro & J & N & J & N & J & N & J & N\\
			\hline
			Zahlungsverhalten einwandfrei? & J & J & N & N & J & J & N & N\\
			\hline
			Kreditgrenze überschritten? & J & J & J & J & N & N & N & N\\
			\hline
			\hline
			Scheck einlösen & X & X & & & X & & X & \\
			\hline
			Scheck nicht einlösen & & & X & X & & & & \\
			\hline
			neue Konditionen vorlegen & & X & & & & & & \\
			\hline
			unlogisch & & & & & & X & & X \\
			\hline
		\end{tabularx}\\
		\par\noindent
		\textbf{Inhaltlich vollständige Entscheidungstabelle}\\
		\begin{tabularx}{\textwidth}{|l||M|M|M|M|M|M|}
			\hline
			\textbf{Scheckeinlösung} & \textbf{R1} & \textbf{R2} & \textbf{R3} & \textbf{R4} & \textbf{R5} & \textbf{R7}\\
			\hline
			Überschreitungsbetrag < 300\euro & J & N & J & N & J & J \\
			\hline
			Zahlungsverhalten einwandfrei? & J & J & N & N & J & N \\
			\hline
			Kreditgrenze überschritten? & J & J & J & J & N & N \\
			\hline
			\hline
			Scheck einlösen & X & X & & & X & X \\
			\hline
			Scheck nicht einlösen & & & X & X & & \\
			\hline
			neue Konditionen vorlegen & & X & & & & \\
			\hline
			unlogisch & & & & & & \\
			\hline
		\end{tabularx}\\
		\subsubsection{Konsolidierung einer Entscheidungstabelle}
		Vollständige Entscheidungstabellen kann man versuchen zu optimieren. Eine Verdichtung überführt eine vollständige Entscheidungstabelle in eine \textbf{konsolidierte Entscheidungstabelle}.\\
		Eine Konsolidierung führt man in folgenden Schritten durch:
		\begin{enumerate}
			\item Existieren Regeln mit identischen Aktionen?
			\begin{itemize}
				\item[\textbf{J}] Betrachte zwei dieser Regeln paarweise.\\
				Unterscheiden sich die Bedingungsanzeiger nur in einer Zeile?
				\begin{itemize}
					\item[\textbf{J}] Fasse diese beiden Regeln zusammen und ersetzt den unterschiedlichen Bedingungsanzeiger durch den Irrelevanzanzeiger (\grqq{}-\grqq{})
					\item[\textbf{N}] Behalte beide Regeln bei.
				\end{itemize}
				\item[\textbf{N}] Die Entscheidungstabelle lässt sich nicht weiter konsolidieren.
			\end{itemize}
		\end{enumerate}
		Für das obige Beispiel ergibt sich nach der Konsolidierung folgende Tabelle:\\
		\begin{tabularx}{\textwidth}{|l||M|M|M|M|}
			\hline
			\textbf{Scheckeinlösung} & \textbf{R1} & \textbf{R2} & \textbf{R3/4} & \textbf{R5/7}\\
			\hline
			Überschreitungsbetrag < 300\euro & J & N & - & - \\
			\hline
			Zahlungsverhalten einwandfrei? & J & J & N & - \\
			\hline
			Kreditgrenze überschritten? & J & J & J & N \\
			\hline
			\hline
			Scheck einlösen & X & X & & X \\
			\hline
			Scheck nicht einlösen & & & X & \\
			\hline
			neue Konditionen vorlegen & & X & & \\
			\hline
			unlogisch & & & & \\
			\hline
		\end{tabularx}
		\subsection{Programmablaufplan}
		Der Programmablaufplan stellt für die unterschiedlichen Verarbeitungen \textbf{Sinnbilder} zur Verfügung, die durch \textbf{Ablauflinien}
		miteinander verbunden sind.\\
		Sinnbilder gliedern sich in folgende Typen:
		\begin{itemize}[label=-]
			\item Sinnbilder für Aktionen (Operation, Verarbeitung)
			\item Sinnbilder für die Ein- und Ausgabe
			\item das Sinnbild \glqq{}Ablauflinie\grqq{}
		\end{itemize}
		\begin{tabularx}{\textwidth}{|c|X|}
			\hline
			Sinnbild & Benennung und Bemerkung\\
			\hline
			\begin{tikzpicture}[node distance = 0.75cm, auto, baseline = -15]
			% Place nodes
			\node[draw=none,fill=none] (tmp2) {};
			\node[process,below of=tmp2](pro){};
			\node[draw=none,fill=none,below of=pro,node distance=0.75cm] (tmp3) {};
			% Draw edges
			\path [line] (tmp2) -- (pro);
			\path [line] (pro) -- (tmp3);
			\end{tikzpicture} & \textbf{Operation allgemein} (process); Insbesondere für die Operation, für die kein besonderes Sinnbild zur Verfügung seht.\\
			\hline
			\begin{tikzpicture}[node distance = 0.75cm, auto, baseline = -15]
			% Place nodes
			\node[draw=none,fill=none,node distance=0.75cm] (tmp1) {};
			\node[decision,below of=tmp1](dec){\color{white}{blah}};
			\node[draw=none,fill=none,right of=dec,node distance=1cm](tmp2){};
			\node[draw=none,fill=none,below of=pro,node distance=0.75cm] (tmp3) {};
			% Draw edges
			\path [line] (tmp1) -- (dec);
			\path [line] (dec) -- (tmp2);
			\path [line] (dec) -- (tmp3);
			\end{tikzpicture} & \textbf{Verzweigung} (decision)\\
			\hline
			\begin{tikzpicture}[node distance = 0.75cm, auto, baseline = -15]
			% Place nodes
			\node[draw=none,fill=none,node distance=0.75cm] (tmp1) {};
			\node[preprocess,below of=tmp1](prepro){};
			\node[draw=none,fill=none,below of=dec,node distance=0.75cm](tmp2){};
			% Draw edges
			\path [line] (tmp1) -- (prepro);
			\path [line] (prepro) -- (tmp2);
			\end{tikzpicture} & \textbf{Unterablauf} (predefined process); Zusammenfassende Darstellung eines an anderer Stelle definierten Ablaufs, z.B. der Ausführung eines Unterprogramms.\\
			\hline
			\begin{tikzpicture}[node distance = 1cm, auto, baseline = -15]
			% Place nodes
			\node[draw=none,fill=none,node distance=1cm] (tmp1) {};
			\node[inout,below of=tmp1](inout){};
			\node[draw=none,fill=none,below of=pro,node distance=1.25cm] (tmp2) {};
			% Draw edges
			\path [line] (tmp1) -- (inout);
			\path [line] (inout) -- (tmp2);
			\end{tikzpicture} & \textbf{Eingabe, Ausgabe} (input/output); Ob es sich um eine maschinelle oder manuelle Eingabe oder Ausgabe handelt, soll aus der Beschriftung des Sinnbildes hervorgehen.\\
			\hline
			\begin{tikzpicture}[node distance = 1cm, auto, baseline = -15]
			% Place nodes
			\node[draw=none,fill=none,node distance=1.25cm] (tmp1) {};
			\node[init,below of=tmp1](init){};
			\node[draw=none,fill=none,below of=pro,node distance=1.25cm] (tmp2) {};
			% Draw edges
			\path [line] (tmp1) -- (init);
			\path [line] (init) -- (tmp2);
			\end{tikzpicture} & \textbf{Grenzstelle} (terminal, interrupt); Innenbeschriftung z.B. \glqq{}Beginn\grqq{}, \glqq{}Ende\grqq{}.\\ 
			\hline
		\end{tabularx}\\
		\par\noindent
		\underline{Regeln für das Erstellen von Programmablaufplänen}
		\begin{itemize}[label=-]
			\item Kein Kreuzen der Ablauflinien
			\item Eingang eines Sinnildes immer oben
			\item Ausgang eines Sinnbildes immer unten
			\item In allen Ablaufplänen, die zu einer Dokumentation gehören, Verzweigungen immer gleich darstellen, d.h. entweder JA- oder NEIN-Zweig immer nach unten führen.
			\item Bei Schleifen mit Verzweigungen Abauflinie auch nach oben möglich.
		\end{itemize}
		\subsection{Struktogramme}
		EIn Nassi-Shneiderman-Diagramm, auch Struktogramm genannt, ist eine Entwurfsmethode für die strukturierte Programmierung, die 1973 von Dr. I. Nass und Dr. B. Shneiderman entwickelt wurde. Es ist genormt nach DIN 66261.\\
		\par\noindent
		Die grafische Darstellung eines Programmablaufs erfolgt in Form eines geschlossenen Blockes, der entsprechend der logischen Grundstrukturen in untergeordnete Blöcke aufteilbar ist. Ein Struktogramm ist zusammengesetzt aus verschiedenen Symbolen für unterschiedliche Operationsarten.\\
		\par\noindent
		\underline{Regeln für die Arbeit mit Struktogrammen}
		\begin{itemize}[label=-]
			\item Die Größe eines Struktogramms ist immer auf eine Seite (DIN-A4) beschränkt.
			\item In Struktogrammen gibt es immer nur einen Eingang und einen Ausgang. Dies gilt auch für die einzelnen Grundsymbole.
			\item Der Programmablauf erfolgt grundsätzlich von oben nach unten.
			\item Die Grundsymbole können ineinander geschachtelt und aneinander gereiht werden.
			\item Alle Programmverzweigungen laufen an einer Stelle wieder zusammen.
			\item Bei der Entwicklung von Struktogrammen ist das Prinzip der schrittweisen Verfeinerung anzuwenden (TOP-DOWN).
			\item Bei größeren Programmen sollte man zusätzlich einen Strukturbaum (hierarchisches Funktionsdiagramm) zur Beschreibung des Gesamtprogramms aufstellen.
		\end{itemize}
		\begin{tabularx}{\textwidth}{|l|l|M|}
			\hline
			Name & \multicolumn{2}{|l|}{Darstellungsform}\\
			\cline{2-3}
			& Pseudocode & Struktogramm\\
			\hline
			& & \\
			\begin{minipage}{0.25\columnwidth}
				Folge\\
				(Verbundanweisung)
			\end{minipage} & \multirow{2}{*}{
				\begin{minipage}{0.25\columnwidth}
					{\lstinline[style=JavaInputStyle]|Anweisung 1|}\\
					{\lstinline[style=JavaInputStyle]|Anweisung 2|}\\
					{\lstinline[style=JavaInputStyle]|...|}\\
					{\lstinline[style=JavaInputStyle]|Anweisung n|}
			\end{minipage}} & \multirow{2}{*}{
				\begin{struktogramm}(40,40)
					\assign{Anweisung 1}
					\assign{Anweisung 2}
					\assign{...}
					\assign{Anweisung n}
			\end{struktogramm}}\\
			& & \\
			& & \\
			& & \\
			\hline
			& & \\
			\begin{minipage}{0.25\columnwidth}
				einseitige Auswahl
			\end{minipage} & \multirow{2}{*}{
				\begin{minipage}{0.25\columnwidth}
					{\lstinline[style=JavaInputStyle]|WENN Bedingung|}\\
					{\lstinline[style=JavaInputStyle]|DANN Anweisung|}
			\end{minipage}} &
			\multirow{2}{*}{
				\begin{struktogramm}(40,40)
					\ifthenelse[10]{1}{1}{b}{J}{N}
					\assign{a1}
					\change
					\assign{\%}
					\ifend
			\end{struktogramm}}\\
			& & \\
			& & \\
			\hline
			& & \\
			\begin{minipage}{0.25\columnwidth}
				zweiseitige Auswahl\\
				(Alternative)
			\end{minipage} & \multirow{2}{*}{
				\begin{minipage}{0.25\columnwidth}
					{\lstinline[style=JavaInputStyle]|WENN Bedingung|}\\
					{\lstinline[style=JavaInputStyle]|DANN Anweisung 1|}\\
					{\lstinline[style=JavaInputStyle]|SONST Anweisung 2|}
			\end{minipage}} & \multirow{2}{*}{
				\begin{struktogramm}(40,40)
					\ifthenelse[10]{1}{1}{b}{J}{N}
					\assign{a1}
					\change
					\assign{a2}
					\ifend
			\end{struktogramm}}\\
			& & \\
			& & \\
			\hline
			& & \\
			\begin{minipage}{0.25\columnwidth}
				mehrseitige Auswahl\\
				(Fallunterscheidung)
			\end{minipage} & \multirow{2}{*}{
				\begin{minipage}{0.25\columnwidth}
					{\lstinline[style=JavaInputStyle]|FALLS Selektor =|}\\
					{\lstinline[style=JavaInputStyle]|1: Anweisung 1|}\\
					{\lstinline[style=JavaInputStyle]|2: Anweisung 2|}\\
					{\lstinline[style=JavaInputStyle]|...|}\\
					{\lstinline[style=JavaInputStyle]|n: Anweisung n|}
			\end{minipage}} & \multirow{2}{*}{
				\begin{struktogramm}(60,40)
					\case{4}{4}{falls s=}{1}
					\assign{\(a_1\)}
					\switch{2}
					\assign{\(a_2\)}
					\switch{...}
					\assign{...}
					\switch{n}
					\assign{\(a_n\)}
					\caseend
			\end{struktogramm}}\\
			& & \\
			& & \\
			& & \\
			& & \\
			\hline
			& & \\
			\begin{minipage}{0.25\columnwidth}
				Wiederholung mit vorangestelltem Test\\
				(mit Eingangsbedingung)
			\end{minipage} & \multirow{2}{*}{
				\begin{minipage}{0.25\columnwidth}
					{\lstinline[style=JavaInputStyle]|SOLANGE b, FÜHRE|}\\
					{\lstinline[style=JavaInputStyle]|Anweisungen|}\\
					{\lstinline[style=JavaInputStyle]|AUS|}
			\end{minipage}} & \multirow{2}{*}{
				\begin{struktogramm}(60,40)
					\while[5]{soange b}
					\assign{Anweisung}
					\whileend
			\end{struktogramm}}\\
			& & \\
			& & \\
			\hline
			& & \\
			\begin{minipage}{0.25\columnwidth}
				Wiederholung mit nachgestelltem Test
			\end{minipage} & \multirow{2}{*}{
				\begin{minipage}{0.25\columnwidth}
					{\lstinline[style=JavaInputStyle]|WIEDERHOLE|}\\
					{\lstinline[style=JavaInputStyle]|Anweisungen|}\\
					{\lstinline[style=JavaInputStyle]|SOLANGE b|}
			\end{minipage}} & \multirow{2}{*}{
				\begin{struktogramm}(60,40)
					\until[5]{solange b}
					\assign{Anweisung}
					\untilend
			\end{struktogramm}}\\
			& & \\
			\hline
			& & \\
			\begin{minipage}{0.25\columnwidth}
				gezählte Wiederholung\\
				(Zählschleife)
			\end{minipage} & \multirow{2}{*}{
				\begin{minipage}{0.25\columnwidth}
					{\lstinline[style=JavaInputStyle]|FÜR i = anfw BIS endw|}\\
					{\lstinline[style=JavaInputStyle]|mit SCHRITTWEITE s|}\\
					{\lstinline[style=JavaInputStyle]|FÜHRE Anweisungen AUS|}
			\end{minipage}} & \multirow{2}{*}{
				\begin{struktogramm}(60,40)
					\while[5]{für i = anfw bis endw\\tue}
					\assign{Anweisung}
					\whileend
			\end{struktogramm}}\\
			& & \\
			& & \\
			\hline
		\end{tabularx}
	\end{worksheet}
\end{document}