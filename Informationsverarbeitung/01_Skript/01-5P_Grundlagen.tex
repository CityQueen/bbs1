\documentclass[11pt,oneside,openany,headings=optiontotoc,11pt,numbers=noenddot]{article}

\input{../../packages.tex}
%arydshln suppresses vertical lines in table
\usepackage{arydshln}
\input{../../makros.tex}

\setlength{\columnsep}{3em}
\setlength{\columnseprule}{0.5pt}

\geometry{left=1.50cm,right=1.50cm,top=3.00cm,bottom=1.00cm,includeheadfoot}
\pagestyle{plain}
\pagenumbering{arabic}

\begin{document}
	\begin{worksheet}{Informationsverarbeitung}{Lernabschnitt: Strukturiert Programmieren}{Grundlegende Programmierelemente}
		\setlength{\columnseprule}{0pt}
		\setcounter{section}{4}
		\setcounter{page}{16}
		\section{Grundlegende Programmierelemente}
		\subsection{Datentypen}
		\label{datyp}
		Bei der Programmierung in Java erinnern wir uns noch an diverse Datentypen. Also die Charakterisierung der möglichen Wertzuweisung einer Variable.\\
		\par\noindent
		\begin{tabularx}{\textwidth}{lXX}
			\textbf{Typ} & \textbf{Beschreibung} & \textbf{Wertebereich / Beispiel}\\
			\hline
			\hline
			{\lstinline[style=Python]{boolean}} & Boolescher Wert & {\lstinline[style=Python]{true, false}}\\
			\hline
			{\lstinline[style=Python]{char}} & einzelnes Zeichen & alle Unicode-Zeichen (Tastatur)\\
			\hline
			{\lstinline[style=Python]{byte}} & eine ganze Zahl (max. 8 Bit) & \(-2^7\ \ldots 2^7-1\)\\
			\hdashline
			{\lstinline[style=Python]{short}} & eine ganze Zahl (max. 16 Bit) & \(-2^{15}\ \ldots 2^{15}-1\)\\
			\hdashline
			{\lstinline[style=Python]{int}} & eine ganze Zahl (max. 32 Bit) & \(-2^{31}\ \ldots 2^{31}-1\)\\
			\hdashline
			{\lstinline[style=Python]{long}} & eine ganze Zahl (max. 64 Bit) & \(-2^{63}\ \ldots 2^{63}-1\)\\
			\hline
			{\lstinline[style=Python]{float}} & Fließkommazahl (max. 32 Bit) & Beispiel: \(3,14159f\)\\
			\hdashline
			{\lstinline[style=Python]{double}} & Fließkommazahl (max. 64 Bit) & Beispiel: \(-1,79 * 10^{38}\)\\
			\hline
			{\lstinline[style=Python]{String}} & Zeichenkette (Wörter / Sätze etc.) & Beispiel: \glqq{}Das ist ein String!\grqq{}\\
			\hdashline
			{\lstinline[style=Python]{int[ ]}} & ganzzahliges Feld (Array) & Beispiel: \({3,1,4,1,5,9}\)\\
			\hline
			\hline
		\end{tabularx}\\
		\par\noindent
		Java unterscheidet zwischen \textbf{zwei Datentypen}. Zum einen gibt es die \textit{primitiven Typen}. Dazu zählen z.B. \lstinline[style=Python]{boolean, char, ... , double}. Zum anderen gibt es die \textit{Referenztypen}. Als solche werden Typen bezeichnet, die entweder primitive Typen enthalten oder aus solchen zusammengesetzt werden. So zum Beispiel Objekte, Strings und Arrays.\\
		Die wichtigen Datentypen werden in einem gesonderten Kapitel behandelt. Dort finden sich auch verschiedene Operationen und Beispiele für die Anwendung der entsprechenden Datentypen.
		\subsection{Operatoren}
		In Java gibt es diverse Operatoren, die bei der Programmierung hilfreich sein können.\\
		\par\noindent
		\begin{tabularx}{\textwidth}{clXX}
			\textbf{Java-Operator} & \textbf{Beschreibung} & \textbf{Anmerkung}\\
			\hline
			\hline
			+ & Addition & \\
			\hline
			- & Subtraktion & \\
			\hline
			* & Multiplikation & \\
			\hline
			/ & Division & Liefert den \underline{Quotienten} von \textbf{x und y}. Sind beide Zahlen ganzzahlig, so auch der Quotient (z.B. 11/5 liefert 2).\\
			\hline
			\% & Modulo & Divisionsrest (z.B 9\%4 = 1)\\
			\hline
			++ & Inkrement & {\lstinline[style=Python]{i++}} entspricht dann {\lstinline[style=Python]{i+1}}\\
			\hline
			\hline
		\end{tabularx}\\
		\par\noindent
		Zusätzlich existieren noch weitere Operatoren die \textbf{Verknüpfung} zweier Variablen ermöglichen.\\
		\begin{tabularx}{\textwidth}{cXX}
			\textbf{Java-Operator} & \textbf{Beschreibung} & \textbf{Anmerkung}\\
			\hline
			\hline
			{\lstinline[style=Python]{=}} & Zuweisung & Der Variablen auf der linken Seite wird der auf der rechten Seite des \(=\)-Zeichen stehende Wert zugewiesen.\\
			\hline
			{\lstinline[style=Python]{==}} & Vergleich & Ermöglicht den Vergleich von \textbf{primitiven Datentypen}. Liefert als Rückgabe {\lstinline[style=Python]{true}} oder {\lstinline[style=Python]{false}}.\\
			\hline
			{\lstinline[style=Python]{<}} & Kleiner & \multirow{4}{*}{Liefert {\lstinline[style=Python]{true}} oder {\lstinline[style=Python]{false}}.}\\
			\cline{1-2}
			{\lstinline[style=Python]{<=}} & Kleiner gleich & \\
			\cline{1-2}
			{\lstinline[style=Python]{>}} & Größer & \\
			\cline{1-2}
			{\lstinline[style=Python]{>=}} & Größer gleich & \\
			\hline
			{\lstinline[style=Python]{!=}} & Ungleich & Ermöglicht den Vergleich von \textbf{primitiven Datentypen}. Liefert als Rückgabe {\lstinline[style=Python]{true}} oder {\lstinline[style=Python]{false}}.\\
			\hline
			{\lstinline[style=Python]{!}} & logisches NICHT & Kehrt die Wertzuweisung der nachfolgenden Variable für die nächste Operation um. Aus {\lstinline[style=Python]{true}} wird {\lstinline[style=Python]{false}}.\\
			\hline
			{\lstinline[style=Python]{||}} & logisches ODER & Entweder \underline{die eine}, \underline{die andere} \textbf{oder} \underline{beide} Bedingungen sind erfüllt.\\
			\hline
			{\lstinline[style=Python]{\&\&}} & logisches UND & Es müssen \underline{beide} Bedingungen erfüllt sein.\\
			\hline
			\hline
		\end{tabularx}\\
		\par\noindent
		\subsection{Klassendefinition}
		Wir erinnern und, dass es sich bei Java um eine sogenannte \textbf{objektorientierte Programmiersprache} handelt. Um ein Objekt überhaupt erzeugen zu können, benötigen wir einen \textit{Bauplan}, der alle nötigen Informationen enthält. Diesen \textit{Bauplan} bezeichnet man auch als \textbf{Klasse}.\\
		Dabei gilt folgende Vorgabe:
		\begin{lstlisting}[style=Python]
			(<Zugriffsart>) class <Bezeichner> (extends <Oberklasse>) {...}
		\end{lstlisting}
		Hierbei ist die Angabe der \lstinline[style=Python]{<Zugriffsart>} notwendig, \lstinline[style=Python]{extends <Oberklasse>} hingegen ist optional.\\
		\par\noindent
		Beispiel:
		\begin{lstlisting}[style=Python,frame=single]
			public class Square{
				/**
				* Deklaration der Attribute
				* Ganzzahlige Attribute für Seitenlänge und Text-Variable für die Farbe werden
				* deklariert.
				**/
				private int length;
				private String color;
				
				/**
				* Methodendefinition
				* Konstruktor zur Erzeugung des Objekts hat den gleichen Namen wie die Klasse.
				**/
				Square(int side1){
					length = side1;
					color = "Red";
				}
				
				public double area(){
					return length*length;
				}
			}	//Ende der Klassendefintion
		\end{lstlisting}
		\subsection{Methodendeklaration}
		Die eben angesprochene Klasse beinhaltet im Allgemeinen Methoden, also \glqq{}Fähigkeiten\grqq{}, die die erzeugten Objekte der Klasse besitzen.\\
		Möchte man eine solche Methode deklarieren, so muss diese Deklaration die folgende Form haben:
		\begin{lstlisting}[style=Python]
			(<Zugriffsart>) <Rückgabewert> <Bezeichner> (<Parameter>) {...}
		\end{lstlisting}
		Wie bei der Klasse ist die Definition der \lstinline[style=Python]{<Zugriffsart>} verpflichtend. Die Angabe \lstinline[style=Python]{<Parameter>} hat die Form \lstinline[style=Python]{<Datentyp> <Bezeichner>}.\\
		Die Definition des \lstinline[style=Python]{<Rückgabewert>} bestimmt, welchen Datentyp die Methode bei Aufruf zurückliefert. Die möglichen Belegungen sind die unter \ref{datyp} genannten, sowie weitere Datentypen. Die Angabe von \lstinline[style=Python]{void} als Rückgabewert sagt aus, dass die Methode keine Rückgabe liefert.\\
		\par\noindent
		Beispiel:
		\begin{lstlisting}[style=Python,frame=single]
			/**
			* Öffentliche Methode hello gibt auf dem Bildschirm "Hallo XYZ" aus, wenn "XYZ" beim
			* Aufruf übergeben wurde.
			**/
			public void hello(String name){
				System.out.println("Hallo " + name);
			}			
			public double umfang(double radius){
				return 2*radius*3,14159;
			}
			
			/**
			* Die Methode goToSleep hat keinen Rückgabewert und keine Parameter.
			* Sie ruft nacheinander die Methoden undress, wash, brushTeeth und lieDown auf.
			**/
			public void goToSleep(){
				undress();
				wash();
				brushTeeth();
				lieDown();
			}
		\end{lstlisting}
		\subsection{Variablendefinition}
		Innerhalb von Klassen, aber auch in Methoden benötigen wir Variablen, mit denen wir arbeiten können. Diese müssen zunächst deklariert werden. Auch hier gibt es eine Deklarationsvorschrift:
		\begin{lstlisting}[style=Python]
			(<Zugriffsart>) <Typ> <Bezeichner> (= <Wert>)
		\end{lstlisting}
		Die direkte Wertzuweisung mittels \lstinline[style=Python]{= <Wert>} kann, muss aber nicht, direkt bei der Variablendeklaration gemacht werden.\\
		Bei dieser \grq{}Wertzuweisung\grq{} ist wichtig zu beachten, dass \textbf{Referenztypen} im Allgemeinen mit dem \lstinline[style=Python]{new}-Operator erzeugt werden müssen. Dies gilt nicht für den Referenztyp \lstinline[style=Python]{String}.\\
		\par\noindent
		Beispiel:
		\begin{lstlisting}[style=Python,frame=single]
			private int anzahl;
			int tage = 15;
			boolean healty;
			
			int[] counter = new int[Größe];
		\end{lstlisting}
		\subsection{Zugriffsart}
		Bei der Definition bzw. Deklaration von Klassen, Methoden und Variablen wird immer nach der ominösen \lstinline[style=Python]{<Zugriffsart>} verlangt. Diese gibt an, wer auf das Objekt und seine Methoden und Variablen zugreifen kann. Dabei gibt es die folgenden Unterscheidungen:
		\begin{itemize}
			\item \textbf{public}\\
			Innerhalb einer Klasse sind die Konstruktoren, Methoden und Variablen sichtbar. Sollen diese auch von Objekten außerhalb der Klasse verwendet werden, definiert man sie als \lstinline[style=Python]{public}.\\
			Deklariert man eine Klasse als \lstinline[style=Python]{public}, so können andere Klassen Instanzen dieser Klasse erzeugen.
			\item \textbf{private}\\
			Dem Gegenüber steht \lstinline[style=Python]{private}. Diese Zugriffsart erlaubt den Zugriff nur innerhalb der Klasse selbst. Das bedeutet auch, dass z.B. Methoden oder Variablen, die als \lstinline[style=Python]{private} deklariert wurden, für andere \underline{nicht} sichtbar sind.
			\item \textbf{protected}\\
			Zusätzlich gibt es die Zugriffsart \lstinline[style=Python]{protected}. Diese dritte Zugriffsart betrifft die Klasse, sowie alle derzeit existierenden und zukünftigen Subklassen.\\
			Auf als \lstinline[style=Python]{protected} deklarierte Konstruktoren, Methoden und Instanzvariablen kann nur von Subklassen zugegriffen werden.\\
			Befinden sich zwei Klassen im gleichen \lstinline[style=Python]{package}, können diese jeweils auf die \lstinline[style=Python]{protected} Bereiche der anderen zugreifen.
			\item \textbf{package (auch friendly oder default)}\\			
			Der \lstinline[style=Python]{default}-Modus tritt immer dann in Kraft,wenn keine ausdrückliche Zugriffsart angegeben wird.\\
		\end{itemize}
		\begin{tabularx}{\textwidth}{cX}
			\textbf{{\lstinline[style=Python]{<Zugriffsart>}}} & \textbf{Beschreibung}\\
			\hline
			\hline
			{\lstinline[style=Python]{public}} & Der Zugriff ist immer möglich. \\
			\hline
			{\lstinline[style=Python]{private}} & Der Zugriff ist nur innerhalb der Klasse möglich.\\
			\hline
			{\lstinline[style=Python]{protected}} & Der Zugriff ist von Klassen innerhalb des gleichen Package möglich. Ebenso kann von Subklassen auf die {\lstinline[style=Python]{protected}} Elemente zugegriffen werden. \\
			\hline
			\hline
			{\lstinline[style=Python]{package}} & Ein Zugriff ist innerhalb der Klasse und von anderen Klassen des gleichen Package möglich. Der Zugriff ist von einer Subklasse aus nicht möglich.\\
			\hline
			\hline
		\end{tabularx}
		\subsection{Einlesen von der Tastatur}
		Um einen Text von der Taststur einzulesen gibt es das Objekt \lstinline[style=Python]|System.in|. Ohne nähere Erklärung der Hintergründe folgt hier zunächst eine Vorstellung, wie eine Ganzzahl von der Tastatur eingelesen werden kann.
		\begin{lstlisting}[style=Python]
			Scanner eingabe = new Scanne(System.in);
			int zahl = eingabe.nextInt();
		\end{lstlisting}
		Mit \texttt{Zeile 1} haben wir ein Objekt erzeugt, das eine Methode zum Einlesen einer Ganzzahl hat. Diese Methode kann über \lstinline[style=Python]|eingabe.nextInt();| zeilenweise von der Tastatur lesen. Das Ergebnis dieser Methode ist vom Typ \lstinline[style=Python]|int| (Integer).\\
		\par\noindent
		\underline{Beispiel:}
		\begin{lstlisting}[style=Python]
			import java.util.*;
			
			class Einlesen{
				public static void main(String[] args){
					int a,b;
					Scanner eingabe = new Scanner(System.in);
					System.out.println("Bitte geben Sie Zahl a ein:");
					a = eingabe.nextInt();
					System.out.println("Bitte geben Sie Zahl b ein:");
					b = eingabe.nextInt();
					
					System.out.println("Sie haben die Zahlen a = " + a + " und b = " + b + " eingegeben.");
				}
			}
		\end{lstlisting}
		\par\noindent
		Eine \textbf{kleine Besonderheit} besteht beim Einlesen eines String. Die Methode \lstinline[style=Python]|eingabe.next()| erkennt über das Betätigen der Enter-Taste nicht, dass die Eingabe beendet wurde. Hier wäre ein doppeltes Enter-Drücken notwendig.\\
		Um dies zu umgehen bietet das Objekt \lstinline[style=Python]|eingabe| die Methode \lstinline[style=Python]|eingabe.nextLine();|. Diese beendet das Einlesen der Tastatureingabe automatisch mit dem Betätigen der Enter-Taste.
	\end{worksheet}
\end{document}