\documentclass[11pt,oneside,openany,headings=optiontotoc,11pt,numbers=noenddot]{article}

\input{../../packages.tex}
\input{../../makros.tex}

\setlength{\columnsep}{3em}
\setlength{\columnseprule}{0.5pt}

\geometry{left=2.50cm,right=2.50cm,top=3.00cm,bottom=1.00cm,includeheadfoot}
\pagestyle{plain}
\pagenumbering{arabic}

\begin{document}
	\begin{worksheet}{Berufliches Gymnasium}{Klassenstufe 12 - Informationsverarbeitung}{Lernabschnitt 0: Wiederholung Java}
		\setlength{\columnseprule}{0pt}
		\begin{framed}
			Datum:
		\end{framed}
		\section{Grundlagen Programmierung}
		\subsection{Datentypen}
		\label{datyp}
		Bei der Programmierung in Java erinnern wir uns noch an diverse Datentypen. Also die Charakterisierung der möglichen Wertzuweisung einer Variable.\\
		\par\noindent
		\begin{tabularx}{\textwidth}{lXX}
			\textbf{Typ} & \textbf{Beschreibung} & \textbf{Wertebereich / Beispiel}\\
			\hline
			\hline
			{\lstinline[style=JavaInputStyle]{boolean}} & Boolescher Wert & {\lstinline[style=JavaInputStyle]{true, false}}\\
			\hline
			{\lstinline[style=JavaInputStyle]{char}} & einzelnes Zeichen & alle Unicode-Zeichen (Tastatur)\\
			\hline
			{\lstinline[style=JavaInputStyle]{byte}} & eine ganze Zahl (max. 8 Bit) & \(-2^7\ \ldots 2^7-1\)\\
			\hdashline
			{\lstinline[style=JavaInputStyle]{short}} & eine ganze Zahl (max. 16 Bit) & \(-2^{15}\ \ldots 2^{15}-1\)\\
			\hdashline
			{\lstinline[style=JavaInputStyle]{int}} & eine ganze Zahl (max. 32 Bit) & \(-2^{31}\ \ldots 2^{31}-1\)\\
			\hdashline
			{\lstinline[style=JavaInputStyle]{long}} & eine ganze Zahl (max. 64 Bit) & \(-2^{63}\ \ldots 2^{63}-1\)\\
			\hline
			{\lstinline[style=JavaInputStyle]{float}} & Fließkommazahl (max. 32 Bit) & Beispiel: \(3,14159f\)\\
			\hdashline
			{\lstinline[style=JavaInputStyle]{double}} & Fließkommazahl (max. 64 Bit) & Beispiel: \(-1,79 * 10^{38}\)\\
			\hline
			{\lstinline[style=JavaInputStyle]{String}} & Zeichenkette (Wörter / Sätze etc.) & Beispiel: \glqq{}Das ist ein String!\grqq{}\\
			\hdashline
			{\lstinline[style=JavaInputStyle]{int[ ]}} & ganzzahliges Feld (Array) & Beispiel: \({3,1,4,1,5,9}\)\\
			\hline
			\hline
		\end{tabularx}\\
		\par\noindent
		Java unterscheidet zwischen \textbf{zwei Datentypen}. Zum einen gibt es die \textit{primitiven Typen}. Dazu zählen z.B. \lstinline[style=JavaInputStyle]{boolean, char, ... , double}. Zum anderen gibt es die \textit{Referenztypen}. Als solche werden Typen bezeichnet, die entweder primitive Typen enthalten oder aus solchen zusammengesetzt werden. So zum Beispiel Objekte, Strings und Arrays.
		\subsection{Operatoren}
		In Java gibt es diverse Operatoren, die bei der Programmierung hilfreich sein können.\\
		\par\noindent
		\begin{tabularx}{\textwidth}{clXX}
			\textbf{Java-Operator} & \textbf{Beschreibung} & \textbf{Anmerkung}\\
			\hline
			\hline
			+ & Addition & \\
			\hline
			- & Subtraktion & \\
			\hline
			* & Multiplikation & \\
			\hline
			/ & Division & Liefert den \underline{Quotienten} von \textbf{x und y}. Sind beide Zahlen ganzzahlig, so auch der Quotient (z.B. 11/5 liefert 2).\\
			\hline
			\% & Modulo & Divisionsrest (z.B 9\%4 = 1)\\
			\hline
			++ & Inkrement & {\lstinline[style=JavaInputStyle]{i++}} entspricht dann {\lstinline[style=JavaInputStyle]{i+1}}\\
			\hline
			\hline
		\end{tabularx}\\
		\par\noindent
		Zusätzlich existieren noch weitere Operatoren die \textbf{Verknüpfung} zweier Variablen ermöglichen.\\
		\begin{tabularx}{\textwidth}{cXX}
			\textbf{Java-Operator} & \textbf{Beschreibung} & \textbf{Anmerkung}\\
			\hline
			\hline
			{\lstinline[style=JavaInputStyle]{=}} & Zuweisung & Der Variablen auf der linken Seite wird der auf der rechten Seite des \(=\)-Zeichen stehende Wert zugewiesen.\\
			\hline
			{\lstinline[style=JavaInputStyle]{==}} & Vergleich & Ermöglicht den Vergleich von \textbf{primitiven Datentypen}. Liefert als Rückgabe {\lstinline[style=JavaInputStyle]{true}} oder {\lstinline[style=JavaInputStyle]{false}}.\\
			\hline
			{\lstinline[style=JavaInputStyle]{<}} & Kleiner & \multirow{4}{*}{Liefert {\lstinline[style=JavaInputStyle]{true}} oder {\lstinline[style=JavaInputStyle]{false}}.}\\
			\cline{1-2}
			{\lstinline[style=JavaInputStyle]{<=}} & Kleiner gleich & \\
			\cline{1-2}
			{\lstinline[style=JavaInputStyle]{>}} & Größer & \\
			\cline{1-2}
			{\lstinline[style=JavaInputStyle]{>=}} & Größer gleich & \\
			\hline
			{\lstinline[style=JavaInputStyle]{!=}} & Ungleich & Ermöglicht den Vergleich von \textbf{primitiven Datentypen}. Liefert als Rückgabe {\lstinline[style=JavaInputStyle]{true}} oder {\lstinline[style=JavaInputStyle]{false}}.\\
			\hline
			{\lstinline[style=JavaInputStyle]{!}} & logisches NICHT & Kehrt die Wertzuweisung der nachfolgenden Variable für die nächste Operation um. Aus {\lstinline[style=JavaInputStyle]{true}} wird {\lstinline[style=JavaInputStyle]{false}}.\\
			\hline
			{\lstinline[style=JavaInputStyle]{||}} & logisches ODER & Entweder \underline{die eine}, \underline{die andere} \textbf{oder} \underline{beide} Bedingungen sind erfüllt.\\
			\hline
			{\lstinline[style=JavaInputStyle]{\&\&}} & logisches UND & Es müssen \underline{beide} Bedingungen erfüllt sein.\\
			\hline
			\hline
		\end{tabularx}\\
		\par\noindent
		\subsection{Klassendefinition}
		Wir erinnern und, dass es sich bei Java um eine sogenannte \textbf{objektorientierte Programmiersprache} handelt. Um ein Objekt überhaupt erzeugen zu können, benötigen wir einen \textit{Bauplan}, der alle nötigen Informationen enthält. Diesen \textit{Bauplan} bezeichnet man auch als \textbf{Klasse}.\\
		Dabei gilt folgende Vorgabe:
		\begin{lstlisting}[style=JavaInputStyle]
			(<Zugriffsart>) class <Bezeichner> (extends <Oberklasse>) {...}
		\end{lstlisting}
		Hierbei ist die Angabe der \lstinline[style=JavaInputStyle]{<Zugriffsart>} notwendig, \lstinline[style=JavaInputStyle]{extends <Oberklasse>} hingegen ist optional.\\
		\par\noindent
		Beispiel:
		\begin{lstlisting}[style=JavaInputStyle,frame=single]
			public class Square{
				/**
				* Deklaration der Attribute
				* Ganzzahlige Attribute für Seitenlänge und Text-Variable für die Farbe werden
				* deklariert.
				**/
				private int length;
				private String color;
				
				/**
				* Methodendefinition
				* Konstruktor zur Erzeugung des Objekts hat den gleichen Namen wie die Klasse.
				**/
				Square(int side1){
					length = side1;
					color = "Red";
				}
				
				public double area(){
					return length*length;
				}
			}	//Ende der Klassendefintion
		\end{lstlisting}
		\subsection{Methodendeklaration}
		Die eben angesprochene Klasse beinhaltet im Allgemeinen Methoden, also \glqq{}Fähigkeiten\grqq{}, die die erzeugten Objekte der Klasse besitzen.\\
		Möchte man eine solche Methode deklarieren, so muss diese Deklaration die folgende Form haben:
		\begin{lstlisting}[style=JavaInputStyle]
			(<Zugriffsart>) <Rückgabewert> <Bezeichner> (<Parameter>) {...}
		\end{lstlisting}
		Wie bei der Klasse ist die Definition der \lstinline[style=JavaInputStyle]{<Zugriffsart>} verpflichtend. Die Angabe \lstinline[style=JavaInputStyle]{<Parameter>} hat die Form \lstinline[style=JavaInputStyle]{<Datentyp> <Bezeichner>}.\\
		Die Definition des \lstinline[style=JavaInputStyle]{<Rückgabewert>} bestimmt, welchen Datentyp die Methode bei Aufruf zurückliefert. Die möglichen Belegungen sind die unter \ref{datyp} genannten, sowie weitere Datentypen. Die Angabe von \lstinline[style=JavaInputStyle]{void} als Rückgabewert sagt aus, dass die Methode keine Rückgabe liefert.\\
		\par\noindent
		Beispiel:
		\begin{lstlisting}[style=JavaInputStyle,frame=single]
			/**
			* Öffentliche Methode hello gibt auf dem Bildschirm "Hallo XYZ" aus, wenn "XYZ" beim
			* Aufruf übergeben wurde.
			**/
			public void hello(String name){
				System.out.println("Hallo " + name);
			}
			
			public double umfang(double radius){
				return 2*radius*3,14159;
			}
			
			/**
			* Die Methode goToSleep hat keinen Rückgabewert und keine Parameter.
			* Sie ruft nacheinander die Methoden undress, wash, brushTeeth und lieDown auf.
			**/
			public void goToSleep(){
				undress();
				wash();
				brushTeeth();
				lieDown();
			}
		\end{lstlisting}
		\subsection{Variablendefinition}
		Innerhalb von Klassen, aber auch in Methoden benötigen wir Variablen, mit denen wir arbeiten können. Diese müssen zunächst deklariert werden. Auch hier gibt es eine Deklarationsvorschrift:
		\begin{lstlisting}[style=JavaInputStyle]
			(<Zugriffsart>) <Typ> <Bezeichner> (= <Wert>)
		\end{lstlisting}
		Die direkte Wertzuweisung mittels \lstinline[style=JavaInputStyle]{= <Wert>} kann, muss aber nicht, direkt bei der Variablendeklaration gemacht werden.\\
		Bei dieser \grq{}Wertzuweisung\grq{} ist wichtig zu beachten, dass \textbf{Referenztypen} im Allgemeinen mit dem \lstinline[style=JavaInputStyle]{new}-Operator erzeugt werden müssen. Dies gilt nicht für den Referenztyp \lstinline[style=JavaInputStyle]{String}.\\
		\par\noindent
		Beispiel:
		\begin{lstlisting}[style=JavaInputStyle,frame=single]
			private int anzahl;
			int tage = 15;
			boolean healty;
			\\
			int[] counter = new int[Größe];
		\end{lstlisting}
		\subsection{Zugriffsart}
		Bei der Definition bzw. Deklaration von Klassen, Methoden und Variablen wird immer nach der ominösen \lstinline[style=JavaInputStyle]{<Zugriffsart>} verlangt. Diese gibt an, wer auf das Objekt und seine Methoden und Variablen zugreifen kann. Dabei gibt es die folgenden Unterscheidungen:
		\begin{itemize}
			\item \textbf{public}\\
			Innerhalb einer Klasse sind die Konstruktoren, Methoden und Variablen sichtbar. Sollen diese auch von Objekten außerhalb der Klasse verwendet werden, definiert man sie als \lstinline[style=JavaInputStyle]{public}.\\
			Deklariert man eine Klasse als \lstinline[style=JavaInputStyle]{public}, so können andere Klassen Instanzen dieser Klasse erzeugen.
			\item \textbf{private}\\
			Dem Gegenüber steht \lstinline[style=JavaInputStyle]{private}. Diese Zugriffsart erlaubt den Zugriff nur innerhalb der Klasse selbst. Das bedeutet auch, dass z.B. Methoden oder Variablen, die als \lstinline[style=JavaInputStyle]{private} deklariert wurden, für andere \underline{nicht} sichtbar sind.
			\item \textbf{protected}\\
			Zusätzlich gibt es die Zugriffsart \lstinline[style=JavaInputStyle]{protected}. Diese dritte Zugriffsart betrifft die Klasse, sowie alle derzeit existierenden und zukünftigen Subklassen.\\
			Auf als \lstinline[style=JavaInputStyle]{protected} deklarierte Konstruktoren, Methoden und Instanzvariablen kann nur von Subklassen zugegriffen werden.\\
			Befinden sich zwei Klassen im gleichen \lstinline[style=JavaInputStyle]{package}, können diese jeweils auf die \lstinline[style=JavaInputStyle]{protected} Bereiche der anderen zugreifen.
			\item \textbf{package (auch friendly oder default)}\\			
			Der \lstinline[style=JavaInputStyle]{default}-Modus tritt immer dann in Kraft,wenn keine ausdrückliche Zugriffsart angegeben wird.\\
		\end{itemize}
		\begin{tabularx}{\textwidth}{cX}
			\textbf{{\lstinline[style=JavaInputStyle]{<Zugriffsart>}}} & \textbf{Beschreibung}\\
			\hline
			\hline
			{\lstinline[style=JavaInputStyle]{public}} & Der Zugriff ist immer möglich. \\
			\hline
			{\lstinline[style=JavaInputStyle]{private}} & Der Zugriff ist nur innerhalb der Klasse möglich.\\
			\hline
			{\lstinline[style=JavaInputStyle]{protected}} & Der Zugriff ist von Klassen innerhalb des gleichen Package möglich. Ebenso kann von Subklassen auf die {\lstinline[style=JavaInputStyle]{protected}} Elemente zugegriffen werden. \\
			\hline
			\hline
			{\lstinline[style=JavaInputStyle]{package}} & Ein Zugriff ist innerhalb der Klasse und von anderen Klassen des gleichen Package möglich. Der Zugriff ist von einer Subklasse aus nicht möglich.\\
			\hline
			\hline
		\end{tabularx}
		\newpage
		\section{Grundlagen Struktogramme}
		Häufig ist es zu Beginn noch nicht klar, in welcher Sprache programmiert wird, so dass die ersten Überlegungen sehr universell sein müssen. Um das Ganze zu realisieren wurde eine Darstellungsform eingeführt, mit der die unterschiedlichen Anweisungen und Befehlsabfolgen allgemein verbildlicht werden können. Diese Darstellungsform wird \textbf{Struktogramm} (auch \textit{Nassi-Schneidermann-Diagramm}) genannt.
		\subsection{Sequenz}
		Mehrere nacheinander ausgeführte Anweisungen, die in Java mit einem Semikolon (;) abgeschlossen werden, werden als \textbf{Sequenz} bezeichnet.\\
		\par\noindent
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			\begin{lstlisting}[style=JavaInputStyle,frame=single]
				wash();
				brushTeeth();
				lieDown();
			\end{lstlisting}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			\begin{struktogramm}(80,60)
				\assign{wash}
				\assign{brush teeth}
				\assign{go to bed}
			\end{struktogramm}
		\end{minipage}
		\subsection{Fallunterscheidung}
		Unter einer Fallunterscheidung versteht man auch eine \textit{bedingte Anweisung}. Diese gibt es zum einen \textbf{mit} und zum anderen \textbf{ohne} Alternative.\\
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			Mit Alternative:
			\begin{lstlisting}[style=JavaInputStyle]
				if(<Bedinung>){
					<Anweisungen>
				}
				else{
					<Anweisungen>
				}
			\end{lstlisting}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			Ohne Alternative:
			\begin{lstlisting}[style=JavaInputStyle]
			if(<Bedingung>) {
				<Anweisungen>
			}
			\end{lstlisting}
		\end{minipage}
		\par\noindent
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			Beispiel mit Alternative:
			\begin{lstlisting}[style=JavaInputStyle,frame=single]
				if(gender == 'm') {
					System.out.println("Sehr geehrter Herr");
				}
				else {
					System.out.println("Sehr geehrte Frau");
				}
			\end{lstlisting}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			\begin{struktogramm}(80,50)[Mit Alternative]
				\ifthenelse[15]{6}{6}
				{isMale?}{Ja}{Nein}
				\assign{\grqq{}Sehr geehrter Herr\grqq{}}
				\change
				\assign{\grqq{}Sehr geehrte Frau\grqq{}}
				\ifend
			\end{struktogramm}
		\end{minipage}
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			Beispiel ohne Alternative:
			\begin{lstlisting}[style=JavaInputStyle,frame=single]
			if(age >= 18) {
				access = true;
			}
			\end{lstlisting}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			\begin{struktogramm}(80,20)[Ohne Alternative]
				\ifthenelse[12]{5}{5}
				{age >= 18}{Ja}{Nein}
				\assign{access granted}
				\change
				\ifend
			\end{struktogramm}
		\end{minipage}
		\par\noindent
		Bei der Fallunterscheidung kann es passieren, dass für verschiedene Bedingungen andere Anweisungen definiert werden. Dabei werden diese der Reihe nach überprüft, bis die erste erfüllt ist. Hierbei müssen aber die entsprechenden Bedingungen definiert werden.
		\par\noindent
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			Beispiel mehrere Bedingungen mit Alternative:
			\begin{lstlisting}[style=JavaInputStyle,frame=single]
			if(age < 16) {
				lightDrinks = false;
				hardDrinks = false;
			}
			else if(age < 18){
				lightDrinks = true;
				hardDrinks = false;
			}
			else{
				lightDrinks = true;
				hardDrinks = true;
			}
			\end{lstlisting}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			\begin{struktogramm}(80,20)[Ohne Alternative]
				\ifthenelse[12]{5}{5}
				{age < 16}{Ja}{Nein}
				\assign{No alcohol!}
				\change
				\ifthenelse[12]{5}{5}{age < 18}{Ja}{Nein}
				\assign{Only soft alcohol!}
				\change
				\assign{Drinks granted!}
				\ifend
				\ifend
			\end{struktogramm}
		\end{minipage}
		\subsection{Mehrfachauswahl}
		Im Gegensatz zur Fallunterscheidung wird bei der der Mehrfachauswahl auf bestimmte Werte geprüft. So dass man hiermit beliebig viele Fälle ohne größeren Aufwand unterscheiden kann.\\
		Die Java-Anweisung für die Mehrfachauswahl ist \lstinline[style=JavaInputStyle]|switch|-Anweisung. Dabei muss aber beachtet werden, dass die zu überprüfende Variable vom Typ \lstinline[style=JavaInputStyle]|byte, short, int| oder \lstinline[style=JavaInputStyle]|char| sein muss.\\
		\par\noindent
		Beispiel Mehrfachauswahl:
		\begin{lstlisting}[style=JavaInputStyle,frame=single]
			switch(<Variable>){
				case <Wert1>: <Anweisung 1>; break;
				case <Wert2>: <Anweisung 2>; break;
				...
				default: <Anweisung n>; break;
			}
		\end{lstlisting}
		Die Anweisung \lstinline[style=JavaInputStyle]|break| erzwingt das Verlassen der gesamten \lstinline[style=JavaInputStyle]|switch|-Anweisung. Die nachfolgenden \lstinline[style=JavaInputStyle]|case|-Bedingungen werden dadurch übersprungen.\\
		\begin{struktogramm}(161,40)
			\case[15]{5}{5}{Note = ?}{1}
			\assign{Mit Auszeichnung bestanden}
			\switch{2}
			\assign{gut bestanden}
			\switch{3}
			\assign{befriedigend bestanden}
			\switch{4}
			\assign{bestanden}
			\switch[r]{sonst}
			\assign{nicht bestanden}
			\caseend

		\end{struktogramm}
		\subsection{Wiederholung}
		In Java hat man die Möglichkeit Anweisungen wiederholen zu lassen, ohne diese durch mehrfache Nennung im Programm-Code zu erzwingen. Dabei gibt es verschiedene Weisen, wie man dies tun kann.
		\subsubsection{Mit fester Anzahl}
		Möchte man beispielsweise etwas für eine bestimmte Anzahl wiederholen, so nutzt man die \lstinline[style=JavaInputStyle]|for|-Anweisung.
		\begin{lstlisting}[style=JavaInputStyle]
			for(<Init>; <Bedingung>; <Update>){
				<Anweisung>
			}
		\end{lstlisting}
		\par\bigskip\noindent
		Die geforderten Parameter haben die folgende Bedeutung:\\
		\begin{tabularx}{\textwidth}{lX}
			{\lstinline[style=JavaInputStyle]|<Init>|} & Deklaration einer ganzzahligen Zählvariable und der Zuweisung eines Anfangswerts (z.B. {\lstinline[style=JavaInputStyle]|int i = 0|})\\
			{\lstinline[style=JavaInputStyle]|<Bedingung>|} & Solange die Bedingung, abhängig von der Zählvariablen, erfüllt ist, werden die Anweisungen ausgeführt (z.B. {\lstinline[style=JavaInputStyle]|i < 5|} - Die Sequenz wird 5 mal ausgeführt)\\
			{\lstinline[style=JavaInputStyle]|<Update>|} & Das Update der Zählvariablen erfolgt nach jedem Durchlauf entsprechend der angegebenen Zuweisung (z.B. {\lstinline[style=JavaInputStyle]|i++|})
		\end{tabularx}
		Zu beachten ist, dass die {\lstinline[style=JavaInputStyle]|<Bedingung>|} immer vor der Ausführung der Sequenz überprüft wird.\\
		\par\noindent
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			Beispiel Abbruchbedingung einbezogen:
			\begin{lstlisting}[style=JavaInputStyle,frame=single]
				/**
				* Berechnet die Summe aller ganzen Zahlen von 0 bis 5.
				*/
				sum = 0;
				for(i=0; i<=5; i++) {
					sum = sum + i;
				}
			\end{lstlisting}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			Beispiel Abbruchbedingung ausgeschlossen:
			\begin{lstlisting}[style=JavaInputStyle,frame=single]
				/**
				* Berechnet die Summe aller ganzen Zahlen von 0 bis 4.
				*/
				sum = 0;
				for(i=0; i<5; i++) {
					sum = sum + i;
				}
			\end{lstlisting}
		\end{minipage}
		\par\noindent
		Die zugehörigen Struktogramme verdeutlichen den minimalen Unterschied in der \lstinline[style=JavaInputStyle]|<Bedingung>|.\\
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			\begin{struktogramm}(78,50)
				\while[10]{Von i:=0 bis 5 tue (wobei i jedes mal um1 erhöht wird)}
				\assign{Erhöhe den Wert der Summe um i}
				\whileend
			\end{struktogramm}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			\begin{struktogramm}(78,50)
				\while[10]{Von i:=0 bis 4 tue (wobei i jedes mal um1 erhöht wird)}
				\assign{Erhöhe den Wert der Summe um i}
				\whileend
			\end{struktogramm}
		\end{minipage}
		\subsubsection{Mit Anfangsbedingung}
		\label{anfb}
		Möchten wir erreichen, dass eine Anweisung oder eine Sequenz solange wiederholt, bis eine bestimmte Bedingung erfüllt wird, nutzt man die \textit{Kopfgestützte} Wiederholung.
		\begin{lstlisting}[style=JavaInputStyle]
			while(<Bedingung>){
				<Anweisungen>
			}
		\end{lstlisting}
		\par\bigskip\noindent
		Wir überprüfen also \underline{\textbf{bevor}} die Sequenz ausgeführt wird, ob die Bedingung erfüllt ist. Dabei kann es also passieren, dass die Sequenz \underline{garnicht} ausgeführt wird.\\
		\par\noindent
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			Beispiel kopfgesteuerte Wiederholung:
			\begin{lstlisting}[style=JavaInputStyle,frame=single]
				int pin = input();
				
				while(pin != 0815){
					System.out.println("Fehlerhafte PIN!");
					pin = input();
				}
			\end{lstlisting}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			\begin{struktogramm}(78,50)[Struktogramm]
				\assign{Eingabe einer ganzen Zahl}
				\while[10]{Solange eingegebene Zahl ungleich 0815}
				\assign{Bildschirmausgabe \grqq{}Fehlerhafte PIN!\grqq{}}
				\assign{Erneute Eingabe einer ganzen Zahl}
				\whileend
			\end{struktogramm}
		\end{minipage}
		\subsubsection{Mit Endbedingung}
		Die in \ref{anfb} erwähnte Wiederholungsanweisung prüft wie es der Name sagt \underline{bevor} die Sequenz ausgeführt wird. Es kann nun aber natürlich auch mal passieren, dass eine solche Sequenz aber mindestens einmal ausgeführt werden soll, bevor die Abbruchbedingung überprüft wird. Um diese Anforderung zu erfüllen nutzt man die entsprechende \textit{Fußgesteuerte} Wiederholung.\\
		\begin{lstlisting}[style=JavaInputStyle]
			do{
				<Anweisungen>
			} while(<Bedingung>)
		\end{lstlisting}
		\par\noindent
		Bei dieser wird die Sequenz \underline{einmal ausgeführt} und die Bedingung wird \textbf{\underline{nach}} jeder Wiederholung überprüft.\\
		\par\noindent
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			Beispiel fußgesteuerte Wiederholung:
			\begin{lstlisting}[style=JavaInputStyle,frame=single]
			do{
				System.out.println(number);
				number--;
			} while(number > 0);
			\end{lstlisting}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{0.48\textwidth}
			\vspace*{0pt}
			\begin{struktogramm}(78,50)[Struktogramm]
				\until[10]{Solange \textit{number} größer Null}
				\assign{Bildschirmausgabe von \textit{number}}
				\assign{Verringere \textit{number} um 1}
				\untilend
			\end{struktogramm}
		\end{minipage}
	\end{worksheet}
\end{document}